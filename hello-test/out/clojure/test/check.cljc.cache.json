["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:imports",null,"~:requires",["^ ","~$clojure.test.check.results","^;","~$rose","~$clojure.test.check.rose-tree","~$results","^;","~$clojure.test.check.impl","^?","^=","^=","~$clojure.test.check.generators","^@","~$gen","^@","~$clojure.test.check.random","^B","~$random","^B"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$get-current-time-millis","^?"],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check.cljc","~:line",242,"~:column",8,"~:end-line",242,"~:end-column",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^R",[["~$rose-tree","~$reporter-fn"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"^P",true,"^7","~$clojure.test.check/shrink-loop","^K","out\\clojure\\test\\check.cljc","^O",19,"~:method-params",["^R",[["^T","^U"]]],"~:protocol-impl",null,"~:arglists-meta",["^R",[null,null]],"^M",1,"~:variadic?",false,"^L",242,"~:ret-tag","~$cljs.core/IMap","^N",242,"~:max-fixed-arity",2,"~:fn-var",true,"^Q",["^R",["^S",["^R",[["^T","^U"]]]]],"^V","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"~$failure",["^ ","^I",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check.cljc","^L",297,"^M",8,"^N",297,"^O",15,"^P",true,"^Q",["^R",["^S",["^R",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed","~$start-time","^U"]]]]]],"^P",true,"^7","~$clojure.test.check/failure","^K","out\\clojure\\test\\check.cljc","^O",15,"^X",["^R",[["^15","^16","^17","^18","^19","^1:","^U"]]],"^Y",null,"^Z",["^R",[null,null]],"^M",1,"^[",false,"^L",297,"^10",["^6",["~$clj","~$any"]],"^N",297,"^12",7,"^13",true,"^Q",["^R",["^S",["^R",[["^15","^16","^17","^18","^19","^1:","^U"]]]]]],"~$make-rng",["^ ","^I",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check.cljc","^L",19,"^M",8,"^N",19,"^O",16,"^P",true,"^Q",["^R",["^S",["^R",[["^19"]]]]]],"^P",true,"^7","~$clojure.test.check/make-rng","^K","out\\clojure\\test\\check.cljc","^O",16,"^X",["^R",[["^19"]]],"^Y",null,"^Z",["^R",[null,null]],"^M",1,"^[",false,"^L",19,"^10","~$cljs.core/IVector","^N",19,"^12",1,"^13",true,"^Q",["^R",["^S",["^R",[["^19"]]]]]],"~$complete",["^ ","^I",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check.cljc","^L",26,"^M",8,"^N",26,"^O",16,"^P",true,"^Q",["^R",["^S",["^R",[["^15","~$num-trials","^19","^1:","^U"]]]]]],"^P",true,"^7","~$clojure.test.check/complete","^K","out\\clojure\\test\\check.cljc","^O",16,"^X",["^R",[["^15","^1B","^19","^1:","^U"]]],"^Y",null,"^Z",["^R",[null,null]],"^M",1,"^[",false,"^L",26,"^10","^11","^N",26,"^12",5,"^13",true,"^Q",["^R",["^S",["^R",[["^15","^1B","^19","^1:","^U"]]]]]],"~$legacy-result",["^ ","^I",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check.cljc","^L",43,"^M",17,"^N",43,"^O",30,"^P",true,"^Q",["^R",["^S",["^R",[["~$result"]]]]],"^V","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"^P",true,"^7","~$clojure.test.check/legacy-result","^K","out\\clojure\\test\\check.cljc","^O",30,"^X",["^R",[["^1E"]]],"^Y",null,"^Z",["^R",[null,null]],"^M",1,"^[",false,"^L",43,"^10",["^6",[null,"^1=","~$cljs.core/ExceptionInfo","~$clj-nil"]],"^N",43,"^12",1,"^13",true,"^Q",["^R",["^S",["^R",[["^1E"]]]]],"^V","Returns a value for the legacy :result key, which has the peculiar\n  property of conflating returned exceptions with thrown exceptions."],"~$quick-check",["^ ","^I",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check.cljc","^L",59,"^M",7,"^N",59,"^O",18,"^Q",["^R",["^S",["^R",[["~$num-tests","^15","~$&",["^ ","~:keys",["^19","~$max-size","^U"],"~:or",["^ ","^1L",200,"^U",["^R",["~$constantly",null]]]]]]]]],"^V","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk. Many\n    of the keys also appear in the quick-check return value, and are\n    documented below.\n\n  If the test passes, the return value will be something like:\n\n      {:num-tests       100,\n       :pass?           true,\n       :result          true,\n       :seed            1561826505982,\n       :time-elapsed-ms 24}\n\n  If the test fails, the return value will be something like:\n\n      {:fail            [0],\n       :failed-after-ms 0,\n       :failing-size    0,\n       :num-tests       1,\n       :pass?           false,\n       :result          false,\n       :result-data     nil,\n       :seed            1561826506080,\n       :shrunk\n       {:depth               0,\n        :pass?               false,\n        :result              false,\n        :result-data         nil,\n        :smallest            [0],\n        :time-shrinking-ms   0,\n        :total-nodes-visited 0}}\n\n  The meaning of the individual entries is:\n\n      :num-tests\n      The total number of trials that was were run, not including\n      shrinking (if applicable)\n\n      :pass?\n      A boolean indicating whether the test passed or failed\n\n      :result\n      A legacy entry that is similar to :pass?\n\n      :seed\n      The seed used for the entire test run; can be used to reproduce\n      a test run by passing it as the :seed option to quick-check\n\n      :time-elapsed-ms\n      The total time, in milliseconds, of a successful test run\n\n      :fail\n      The generated values for the first failure; note that this is\n      always a vector, since prop/for-all can have multiple clauses\n\n      :failed-after-ms\n      The total time, in milliseconds, spent finding the first failing\n      trial\n\n      :failing-size\n      The value of the size parameter used to generate the first\n      failure\n\n      :result-data\n      The result data, if any, of the first failing trial (to take\n      advantage of this a property must return an object satisfying\n      the clojure.test.check.results/Result protocol)\n\n      :shrunk\n      A map of data about the shrinking process; nested keys that\n      appear at the top level have the same meaning; other keys are\n      documented next\n\n      :shrunk / :depth\n      The depth in the shrink tree that the smallest failing instance\n      was found; this is essentially the idea of how many times the\n      original failure was successfully shrunk\n\n      :smallest\n      The smallest values found in the shrinking process that still\n      fail the test; this is a vector of the same type as :fail\n\n      :time-shrinking-ms\n      The total time, in milliseconds, spent shrinking\n\n      :total-nodes-visited\n      The total number of steps in the shrinking process\n\n  Examples:\n\n      (def p (for-all [a gen/nat] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))","~:top-fn",["^ ","^[",true,"~:fixed-arity",2,"^12",2,"^X",[["^R",["^1J","^15",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^Q",["^R",[["^1J","^15","~$&",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^Z",["^R",[null]]]],"^7","~$clojure.test.check/quick-check","^K","out\\clojure\\test\\check.cljc","^O",18,"^1O",["^ ","^[",true,"^1P",2,"^12",2,"^X",[["^R",["^1J","^15",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^Q",["^R",[["^1J","^15","~$&",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^Z",["^R",[null]]],"^X",[["^R",["^1J","^15",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^Y",null,"^1P",2,"^Z",["^R",[null]],"^M",1,"^[",true,"~:methods",[["^ ","^1P",2,"^[",true,"~:tag",["^6",["^1=","^11"]]]],"^L",59,"^10","^1=","^N",59,"^12",2,"^13",true,"^Q",["^R",[["^1J","^15","~$&",["^ ","^1K",["^19","^1L","^U"],"^1M",["^ ","^1L",200,"^U",["^R",["^1N",null]]]]]]],"^V","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type            :trial\n       :args            [...]\n       :num-tests       <number of tests run so far>\n       :num-tests-total <total number of tests to be run>\n       :seed            42\n       :pass?           true\n       :property        #<...>\n       :result          true\n       :result-data     {...}}\n\n      ;; called after the first failing trial\n      {:type         :failure\n       :fail         [...failing args...]\n       :failing-size 13\n       :num-tests    <tests ran before failure found>\n       :pass?        false\n       :property     #<...>\n       :result       false/exception\n       :result-data  {...}\n       :seed         42}\n\n    It will also be called on :complete, :shrink-step and :shrunk. Many\n    of the keys also appear in the quick-check return value, and are\n    documented below.\n\n  If the test passes, the return value will be something like:\n\n      {:num-tests       100,\n       :pass?           true,\n       :result          true,\n       :seed            1561826505982,\n       :time-elapsed-ms 24}\n\n  If the test fails, the return value will be something like:\n\n      {:fail            [0],\n       :failed-after-ms 0,\n       :failing-size    0,\n       :num-tests       1,\n       :pass?           false,\n       :result          false,\n       :result-data     nil,\n       :seed            1561826506080,\n       :shrunk\n       {:depth               0,\n        :pass?               false,\n        :result              false,\n        :result-data         nil,\n        :smallest            [0],\n        :time-shrinking-ms   0,\n        :total-nodes-visited 0}}\n\n  The meaning of the individual entries is:\n\n      :num-tests\n      The total number of trials that was were run, not including\n      shrinking (if applicable)\n\n      :pass?\n      A boolean indicating whether the test passed or failed\n\n      :result\n      A legacy entry that is similar to :pass?\n\n      :seed\n      The seed used for the entire test run; can be used to reproduce\n      a test run by passing it as the :seed option to quick-check\n\n      :time-elapsed-ms\n      The total time, in milliseconds, of a successful test run\n\n      :fail\n      The generated values for the first failure; note that this is\n      always a vector, since prop/for-all can have multiple clauses\n\n      :failed-after-ms\n      The total time, in milliseconds, spent finding the first failing\n      trial\n\n      :failing-size\n      The value of the size parameter used to generate the first\n      failure\n\n      :result-data\n      The result data, if any, of the first failing trial (to take\n      advantage of this a property must return an object satisfying\n      the clojure.test.check.results/Result protocol)\n\n      :shrunk\n      A map of data about the shrinking process; nested keys that\n      appear at the top level have the same meaning; other keys are\n      documented next\n\n      :shrunk / :depth\n      The depth in the shrink tree that the smallest failing instance\n      was found; this is essentially the idea of how many times the\n      original failure was successfully shrunk\n\n      :smallest\n      The smallest values found in the shrinking process that still\n      fail the test; this is a vector of the same type as :fail\n\n      :time-shrinking-ms\n      The total time, in milliseconds, spent shrinking\n\n      :total-nodes-visited\n      The total number of steps in the shrinking process\n\n  Examples:\n\n      (def p (for-all [a gen/nat] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))"],"~$smallest-shrink",["^ ","^I",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check.cljc","^L",231,"^M",8,"^N",231,"^O",23,"^P",true,"^Q",["^R",["^S",["^R",[["~$total-nodes-visited","~$depth","~$smallest","^1:"]]]]]],"^P",true,"^7","~$clojure.test.check/smallest-shrink","^K","out\\clojure\\test\\check.cljc","^O",23,"^X",["^R",[["^1U","^1V","^1W","^1:"]]],"^Y",null,"^Z",["^R",[null,null]],"^M",1,"^[",false,"^L",231,"^10","^11","^N",231,"^12",4,"^13",true,"^Q",["^R",["^S",["^R",[["^1U","^1V","^1W","^1:"]]]]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^A","^@","^@","^@"],"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["~:args","~:clojure.test.check.properties/error","~:shrunk","~:failed-after-ms","~:total-nodes-visited","~:num-tests-total","~:failure","~:property","~:shrink-step","~:num-tests","~:type","~:max-size","~:seed","~:fail","~:result","~:result-data","~:smallest","~:trial","~:time-shrinking-ms","~:failing-size","~:reporter-fn","~:pass?","~:depth","~:complete","~:shrinking","~:time-elapsed-ms"]],"~:order",["^2;","^28","^2?","^2F","^2:","^2J","^2=","^2H","^22","^2<","^2E","^21","^26","^2@","^2B","^25","^2G","^2C","^2A","^2I","^29","^24","^2>","^2D","^27","^23"]],"^V",null]