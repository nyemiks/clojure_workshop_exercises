["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ ","~$for-all","~$clojure.test.check.properties"],"~:excludes",["~#set",[]],"~:name","^6","~:imports",null,"~:requires",["^ ","~$gen","~$clojure.test.check.generators","^=","^=","~$results","~$clojure.test.check.results","^?","^?"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$exception?",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\properties.cljc","~:line",23,"~:column",17,"~:end-line",23,"~:end-column",27,"~:private",true,"~:arglists",["~#list",["~$quote",["^M",[["~$x"]]]]]],"^K",true,"^9","~$clojure.test.check.properties/exception?","^F","out\\clojure\\test\\check\\properties.cljc","^J",27,"~:method-params",["^M",[["~$x"]]],"~:protocol-impl",null,"~:arglists-meta",["^M",[null,null]],"^H",1,"~:variadic?",false,"^G",23,"~:ret-tag","~$boolean","^I",23,"~:max-fixed-arity",1,"~:fn-var",true,"^L",["^M",["^N",["^M",[["~$x"]]]]]],"~$->ErrorResult",["^ ","^D",null,"^E",["^ ","^F","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\properties.cljc","^J",23,"^H",12,"~:internal-ctor",true,"~:factory","~:positional","^G",15,"^I",15,"^L",["^M",["^N",["^M",[["~$error"]]]]],"~:doc","Positional factory function for clojure.test.check.properties/ErrorResult."],"^9","~$clojure.test.check.properties/->ErrorResult","^F","out\\clojure\\test\\check\\properties.cljc","^J",23,"^P",["^M",[["^10"]]],"^Q",null,"^R",["^M",[null,null]],"^H",1,"^Y",true,"^S",false,"^Z","^[","^G",15,"^T","~$clojure.test.check.properties/ErrorResult","^I",15,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[["^10"]]]]],"^11","Positional factory function for clojure.test.check.properties/ErrorResult."],"~$binding-gens",["^ ","^D",null,"^E",["^ ","^F","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\properties.cljc","^G",64,"^H",8,"^I",64,"^J",20,"^K",true,"^L",["^M",["^N",["^M",[["~$bindings"]]]]]],"^K",true,"^9","~$clojure.test.check.properties/binding-gens","^F","out\\clojure\\test\\check\\properties.cljc","^J",20,"^P",["^M",[["^15"]]],"^Q",null,"^R",["^M",[null,null]],"^H",1,"^S",false,"^G",64,"^T","~$cljs.core/LazySeq","^I",64,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[["^15"]]]]]],"^5",["^ ","^D",null,"^E",["^ ","^F","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\properties.cljc","^J",18,"~:top-fn",["^ ","^S",true,"~:fixed-arity",1,"^V",1,"^P",["^M",[["^M",["^15","~$body"]]]],"^L",["^M",[["^15","~$&","^1:"]]],"^R",["^M",[null]]],"^H",11,"^G",68,"~:macro",true,"^I",68,"^L",["^M",["^N",["^M",[["^15","~$&","^1:"]]]]],"^11","Returns a property, which is the combination of some generators and\n  an assertion that should be true for all generated values. Properties\n  can be used with `quick-check` or `defspec`.\n\n  `for-all` takes a `let`-style bindings vector, where the right-hand\n  side of each binding is a generator.\n\n  The body should be an expression of the generated values that will\n  be tested for truthiness, unless it is a special implementation of\n  the clojure.test.check.results/Result protocol. Exceptions in the\n  body will be caught and treated as failures.\n\n  When there are multiple binding pairs, the earlier pairs are not\n  visible to the later pairs.\n\n  If there are multiple body expressions, all but the last one are\n  executed for side effects, as with `do`.\n\n  Example:\n\n  (for-all [a gen/large-integer\n            b gen/large-integer]\n    (>= (+ a b) a))"],"^9","~$clojure.test.check.properties/for-all","^F","out\\clojure\\test\\check\\properties.cljc","^J",18,"^18",["^ ","^S",true,"^19",1,"^V",1,"^P",["^M",[["^M",["^15","^1:"]]]],"^L",["^M",[["^15","~$&","^1:"]]],"^R",["^M",[null]]],"^P",["^M",[["^M",["^15","^1:"]]]],"^Q",null,"^19",1,"^R",["^M",[null]],"^H",1,"^S",true,"~:methods",[["^ ","^19",1,"^S",true,"~:tag",["^8",["~$seq","~$cljs.core/IList"]]]],"^G",68,"^1;",true,"^T","~$any","^I",68,"^V",1,"^W",false,"^L",["^M",[["^15","~$&","^1:"]]],"^11","Returns a property, which is the combination of some generators and\n  an assertion that should be true for all generated values. Properties\n  can be used with `quick-check` or `defspec`.\n\n  `for-all` takes a `let`-style bindings vector, where the right-hand\n  side of each binding is a generator.\n\n  The body should be an expression of the generated values that will\n  be tested for truthiness, unless it is a special implementation of\n  the clojure.test.check.results/Result protocol. Exceptions in the\n  body will be caught and treated as failures.\n\n  When there are multiple binding pairs, the earlier pairs are not\n  visible to the later pairs.\n\n  If there are multiple body expressions, all but the last one are\n  executed for side effects, as with `do`.\n\n  Example:\n\n  (for-all [a gen/large-integer\n            b gen/large-integer]\n    (>= (+ a b) a))"],"~$apply-gen",["^ ","^D",null,"^E",["^ ","^F","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\properties.cljc","^G",27,"^H",17,"^I",27,"^J",26,"^K",true,"^L",["^M",["^N",["^M",[["~$function"]]]]]],"^K",true,"^9","~$clojure.test.check.properties/apply-gen","^F","out\\clojure\\test\\check\\properties.cljc","^J",26,"^P",["^M",[["^1C"]]],"^Q",null,"^R",["^M",[null,null]],"^H",1,"^S",false,"^G",27,"^T","^1C","^I",27,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[["^1C"]]]]]],"~$for-all*",["^ ","^D",null,"^E",["^ ","^F","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\properties.cljc","^G",45,"^H",7,"^I",45,"^J",15,"^L",["^M",["^N",["^M",[["~$args","^1C"]]]]],"^11","A function version of `for-all`. Takes a sequence of N generators\n  and a function of N args, and returns a property that calls the\n  function with generated values and tests the return value for\n  truthiness, like with `for-all`.\n\n  Example:\n\n  (for-all* [gen/large-integer gen/large-integer]\n            (fn [a b] (>= (+ a b) a)))"],"^9","~$clojure.test.check.properties/for-all*","^F","out\\clojure\\test\\check\\properties.cljc","^J",15,"^P",["^M",[["^1F","^1C"]]],"^Q",null,"^R",["^M",[null,null]],"^H",1,"^S",false,"^G",45,"^T","~$clojure.test.check.generators/Generator","^I",45,"^V",2,"^W",true,"^L",["^M",["^N",["^M",[["^1F","^1C"]]]]],"^11","A function version of `for-all`. Takes a sequence of N generators\n  and a function of N args, and returns a property that calls the\n  function with generated values and tests the return value for\n  truthiness, like with `for-all`.\n\n  Example:\n\n  (for-all* [gen/large-integer gen/large-integer]\n            (fn [a b] (>= (+ a b) a)))"],"~$map->ErrorResult",["^ ","^D",null,"^E",["^ ","^F","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\properties.cljc","^J",23,"^H",12,"^Y",true,"^Z","~:map","^G",15,"^I",15,"^L",["^M",["^N",["^M",[["~$G__4780"]]]]],"^11","Factory function for clojure.test.check.properties/ErrorResult, taking a map of keywords to field values."],"^9","~$clojure.test.check.properties/map->ErrorResult","^F","out\\clojure\\test\\check\\properties.cljc","^J",23,"^P",["^M",[["^1K"]]],"^Q",null,"^R",["^M",[null,null]],"^H",1,"^Y",true,"^S",false,"^Z","^1J","^G",15,"^T","^13","^I",15,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[["^1K"]]]]],"^11","Factory function for clojure.test.check.properties/ErrorResult, taking a map of keywords to field values."],"~$binding-vars",["^ ","^D",null,"^E",["^ ","^F","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\properties.cljc","^G",60,"^H",8,"^I",60,"^J",20,"^K",true,"^L",["^M",["^N",["^M",[["^15"]]]]]],"^K",true,"^9","~$clojure.test.check.properties/binding-vars","^F","out\\clojure\\test\\check\\properties.cljc","^J",20,"^P",["^M",[["^15"]]],"^Q",null,"^R",["^M",[null,null]],"^H",1,"^S",false,"^G",60,"^T","^17","^I",60,"^V",1,"^W",true,"^L",["^M",["^N",["^M",[["^15"]]]]]],"~$ErrorResult",["^ ","~:num-fields",1,"~:protocols",["^8",["~$cljs.core/IRecord","~$cljs.core/IKVReduce","~$cljs.core/IEquiv","~$cljs.core/IHash","~$cljs.core/ICollection","~$cljs.core/ICounted","~$cljs.core/ISeqable","~$cljs.core/IMeta","~$clojure.test.check.results/Result","~$cljs.core/ICloneable","~$cljs.core/IPrintWithWriter","~$cljs.core/IIterable","~$cljs.core/IWithMeta","~$cljs.core/IAssociative","~$cljs.core/IMap","~$cljs.core/ILookup"]],"^9","^13","^F","out\\clojure\\test\\check\\properties.cljc","^J",23,"~:type",true,"^H",12,"^Y",true,"^G",15,"~:record",true,"^I",15,"^1>","^1C","~:skip-protocol-flag",["^8",["^1R","^1S","^1T","^1U","^1V","^1W","^1X","^1Y","^1[","^20","^21","^22","^23","^24","^25"]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^6","^6","^<","^=","^=","^="],"~:cljs.analyzer/constants",["^ ","~:seen",["^8",["~:args","~:clojure.test.check.properties/error","^1G","~:function","~:result","~$cljs.core/fn","~:error","^10"]],"~:order",["^2B","^2>","^10","^2@","^2?","^2=","^1G","^2A"]],"^11",null]