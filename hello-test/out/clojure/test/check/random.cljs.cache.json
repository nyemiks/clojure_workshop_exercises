["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Date",["^ ","~$prototype",["^ ","~$valueOf",["^ "]]],"~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",["~$bit-count","~$bit-xor","~$unsigned-bit-shift-right","~$*","~$bit-or","~$+"]],"~:name","~$clojure.test.check.random","~:imports",null,"~:requires",["^ ","~$doubles","~$clojure.test.check.random.doubles","^C","^C","~$longs","~$clojure.test.check.random.longs","^E","^E"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","^:","^E","^;","^E","^<","^E","~$*","^E","^=","^E","~$+","^E"],"~:defs",["^ ","~$mix-gamma-const-1",["^ ","~:meta",["^ ","~:file","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","~:line",71,"~:column",16,"~:end-line",71,"~:end-column",33,"~:private",true],"^P",true,"^>","~$clojure.test.check.random/mix-gamma-const-1","^K","out\\clojure\\test\\check\\random.cljs","^O",33,"^M",1,"^L",71,"^N",71,"~:tag","~$any"],"~$make-java-util-splittable-random",["^ ","~:protocol-inline",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",123,"^M",7,"^N",123,"^O",39,"~:arglists",["~#list",["~$quote",["^W",[["~$seed"]]]]]],"^>","~$clojure.test.check.random/make-java-util-splittable-random","^K","out\\clojure\\test\\check\\random.cljs","^O",39,"~:method-params",["^W",[["^Y"]]],"~:protocol-impl",null,"~:arglists-meta",["^W",[null,null]],"^M",1,"~:variadic?",false,"^L",123,"~:ret-tag","~$clojure.test.check.random/JavaUtilSplittableRandom","^N",123,"~:max-fixed-arity",1,"~:fn-var",true,"^V",["^W",["^X",["^W",[["^Y"]]]]]],"~$rand-long",["^ ","^U",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",20,"^M",4,"^N",20,"^O",13,"~:protocol","~$clojure.test.check.random/IRandom","~:doc","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^V",["^W",["^X",["^W",[["~$rng"]]]]]],"^18","^19","^>","~$clojure.test.check.random/rand-long","^K","out\\clojure\\test\\check\\random.cljs","^O",13,"^[",["^W",[["^1;"]]],"^10",null,"^11",["^W",[null,null]],"^M",1,"^12",false,"^L",19,"^13","^S","^N",20,"^15",1,"^16",true,"^V",["^W",["^X",["^W",[["^1;"]]]]],"^1:","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$mix-64",["^ ","^U",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",62,"^M",17,"^N",62,"^O",23,"^P",true,"^V",["^W",["^X",["^W",[["~$n"]]]]]],"^P",true,"^>","~$clojure.test.check.random/mix-64","^K","out\\clojure\\test\\check\\random.cljs","^O",23,"^[",["^W",[["~$n"]]],"^10",null,"^11",["^W",[null,null]],"^M",1,"^12",false,"^L",62,"^13","^S","^N",62,"^15",1,"^16",true,"^V",["^W",["^X",["^W",[["~$n"]]]]]],"~$golden-gamma",["^ ","^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",120,"^M",16,"^N",120,"^O",28,"^P",true],"^P",true,"^>","~$clojure.test.check.random/golden-gamma","^K","out\\clojure\\test\\check\\random.cljs","^O",28,"^M",1,"^L",120,"^N",120,"^R","^S"],"~$mix-gamma-const-2",["^ ","^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",72,"^M",16,"^N",72,"^O",33,"^P",true],"^P",true,"^>","~$clojure.test.check.random/mix-gamma-const-2","^K","out\\clojure\\test\\check\\random.cljs","^O",33,"^M",1,"^L",72,"^N",72,"^R","^S"],"~$mix-64-const-2",["^ ","^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",60,"^M",16,"^N",60,"^O",30,"^P",true],"^P",true,"^>","~$clojure.test.check.random/mix-64-const-2","^K","out\\clojure\\test\\check\\random.cljs","^O",30,"^M",1,"^L",60,"^N",60,"^R","^S"],"~$bxoubsr",["^ ","^U",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",54,"^M",17,"^N",54,"^O",24,"^P",true,"^V",["^W",["^X",["^W",[["~$x","~$n"]]]]],"^1:","Performs (-> x (unsigned-bit-shift-right n) (bit-xor x))."],"^P",true,"^>","~$clojure.test.check.random/bxoubsr","^K","out\\clojure\\test\\check\\random.cljs","^O",24,"^[",["^W",[["~$x","~$n"]]],"^10",null,"^11",["^W",[null,null]],"^M",1,"^12",false,"^L",54,"^13","^S","^N",54,"^15",2,"^16",true,"^V",["^W",["^X",["^W",[["~$x","~$n"]]]]],"^1:","Performs (-> x (unsigned-bit-shift-right n) (bit-xor x))."],"~$make-random",["^ ","^U",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",139,"^M",7,"^N",139,"^O",18,"^V",["^W",["^X",["^W",[[],["^Y"]]]]],"^1:","Given an optional integer (or goog.math.Long) seed, returns an\n  implementation of the IRandom protocol.","~:top-fn",["^ ","^12",false,"~:fixed-arity",1,"^15",1,"^[",["^W",[[],["^Y"]]],"^V",["^W",[[],["^Y"]]],"^11",["^W",[null,null]]]],"^>","~$clojure.test.check.random/make-random","^K","out\\clojure\\test\\check\\random.cljs","^O",18,"^1H",["^ ","^12",false,"^1I",1,"^15",1,"^[",["^W",[[],["^Y"]]],"^V",["^W",[[],["^Y"]]],"^11",["^W",[null,null]]],"^[",["^W",[[],["^Y"]]],"^10",null,"^1I",1,"^11",["^W",[null,null]],"^M",1,"^12",false,"~:methods",[["^ ","^1I",0,"^12",false,"^R","^S"],["^ ","^1I",1,"^12",false,"^R","^14"]],"^L",139,"^N",139,"^15",1,"^16",true,"^V",["^W",[[],["^Y"]]],"^1:","Given an optional integer (or goog.math.Long) seed, returns an\n  implementation of the IRandom protocol."],"~$mix-gamma",["^ ","^U",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",75,"^M",17,"^N",75,"^O",26,"^P",true,"^V",["^W",["^X",["^W",[["~$n"]]]]]],"^P",true,"^>","~$clojure.test.check.random/mix-gamma","^K","out\\clojure\\test\\check\\random.cljs","^O",26,"^[",["^W",[["~$n"]]],"^10",null,"^11",["^W",[null,null]],"^M",1,"^12",false,"^L",75,"^13","^S","^N",75,"^15",1,"^16",true,"^V",["^W",["^X",["^W",[["~$n"]]]]]],"~$mix-gamma-const-3",["^ ","^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",73,"^M",16,"^N",73,"^O",33,"^P",true],"^P",true,"^>","~$clojure.test.check.random/mix-gamma-const-3","^K","out\\clojure\\test\\check\\random.cljs","^O",33,"^M",1,"^L",73,"^N",73,"^R","^S"],"~$split-n",["^ ","^U",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",37,"^M",4,"^N",37,"^O",11,"^18","^19","^1:","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^V",["^W",["^X",["^W",[["^1;","~$n"]]]]]],"^18","^19","^>","~$clojure.test.check.random/split-n","^K","out\\clojure\\test\\check\\random.cljs","^O",11,"^[",["^W",[["^1;","~$n"]]],"^10",null,"^11",["^W",[null,null]],"^M",1,"^12",false,"^L",19,"^13","^S","^N",37,"^15",2,"^16",true,"^V",["^W",["^X",["^W",[["^1;","~$n"]]]]],"^1:","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$next-rng",["^ ","^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",130,"^M",16,"^N",130,"^O",24,"^P",true],"^P",true,"^>","~$clojure.test.check.random/next-rng","^K","out\\clojure\\test\\check\\random.cljs","^O",24,"^M",1,"^L",130,"^N",130,"^R","~$function"],"~$hex-long",["^ ","^U",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",49,"^M",17,"^N",49,"^O",25,"^P",true,"^V",["^W",["^X",["^W",[["~$s"]]]]],"^1:","Helper for defining constants."],"^P",true,"^>","~$clojure.test.check.random/hex-long","^K","out\\clojure\\test\\check\\random.cljs","^O",25,"^[",["^W",[["~$s"]]],"^10",null,"^11",["^W",[null,null]],"^M",1,"^12",false,"^L",49,"^13","^S","^N",49,"^15",1,"^16",true,"^V",["^W",["^X",["^W",[["~$s"]]]]],"^1:","Helper for defining constants."],"~$rand-double",["^ ","^U",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",25,"^M",4,"^N",25,"^O",15,"^18","^19","^1:","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^V",["^W",["^X",["^W",[["^1;"]]]]]],"^18","^19","^>","~$clojure.test.check.random/rand-double","^K","out\\clojure\\test\\check\\random.cljs","^O",15,"^[",["^W",[["^1;"]]],"^10",null,"^11",["^W",[null,null]],"^M",1,"^12",false,"^L",19,"^13","^S","^N",25,"^15",1,"^16",true,"^V",["^W",["^X",["^W",[["^1;"]]]]],"^1:","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$mix-64-const-1",["^ ","^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",59,"^M",16,"^N",59,"^O",30,"^P",true],"^P",true,"^>","~$clojure.test.check.random/mix-64-const-1","^K","out\\clojure\\test\\check\\random.cljs","^O",30,"^M",1,"^L",59,"^N",59,"^R","^S"],"~$split",["^ ","^U",null,"^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",31,"^M",4,"^N",31,"^O",9,"^18","^19","^1:","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^V",["^W",["^X",["^W",[["^1;"]]]]]],"^18","^19","^>","~$clojure.test.check.random/split","^K","out\\clojure\\test\\check\\random.cljs","^O",9,"^[",["^W",[["^1;"]]],"^10",null,"^11",["^W",[null,null]],"^M",1,"^12",false,"^L",19,"^13","^S","^N",31,"^15",1,"^16",true,"^V",["^W",["^X",["^W",[["^1;"]]]]],"^1:","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$JavaUtilSplittableRandom",["^ ","~:num-fields",2,"~:protocols",["^9",["^19"]],"^>","^14","^K","out\\clojure\\test\\check\\random.cljs","^O",34,"~:type",true,"^M",10,"^L",91,"~:record",false,"^N",91,"^R","^1T","~:skip-protocol-flag",null],"~$IRandom",["^ ","^J",["^ ","^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^L",19,"^M",14,"^N",19,"^O",21,"~:protocol-symbol",true,"~:jsdoc",["^W",["@interface"]],"~:protocol-info",["^ ","^1K",["^ ","^17",[["^1;"]],"^1W",[["^1;"]],"^1[",[["^1;"]],"^1P",[["^1;","~$n"]]]]],"^28",true,"^>","^19","^K","out\\clojure\\test\\check\\random.cljs","^O",21,"^M",1,"^L",19,"^2:",["^ ","^1K",["^ ","^17",[["^1;"]],"^1W",[["^1;"]],"^1[",[["^1;"]],"^1P",[["^1;","~$n"]]]],"~:info",null,"^N",19,"^R","^S","~:impls",["^9",["^14"]],"^29",["^W",["@interface"]]],"~$->JavaUtilSplittableRandom",["^ ","^U",null,"^J",["^ ","^23",["^9",["^19"]],"^K","C:\\Users\\nyemi\\Documents\\clojure\\workshop_activity\\hello-test\\out\\clojure\\test\\check\\random.cljs","^O",34,"^M",10,"~:factory","~:positional","^L",91,"^N",91,"^V",["^W",["^X",["^W",[["~$gamma","~$state"]]]]],"^26",null,"^1:","Positional factory function for clojure.test.check.random/JavaUtilSplittableRandom."],"^23",["^9",["^19"]],"^>","~$clojure.test.check.random/->JavaUtilSplittableRandom","^K","out\\clojure\\test\\check\\random.cljs","^O",34,"^[",["^W",[["^2@","^2A"]]],"^10",null,"^11",["^W",[null,null]],"^M",1,"^12",false,"^2>","^2?","^L",91,"^13","^14","^N",91,"^15",2,"^16",true,"^V",["^W",["^X",["^W",[["^2@","^2A"]]]]],"^26",null,"^1:","Positional factory function for clojure.test.check.random/JavaUtilSplittableRandom."]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^9",["~:returned","~:state","~:seed","^2A","^2@"]],"~:order",["^2@","^2A","^2I","^2H","^2G"]],"^1:","Purely functional and splittable pseudo-random number generators."]